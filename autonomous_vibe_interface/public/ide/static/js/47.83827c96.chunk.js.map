{"version":3,"file":"static/js/47.83827c96.chunk.js","mappings":"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","sources":["services/magic/TestingFramework.ts"],"sourcesContent":["/**\n * Testing Framework Service\n * Automatically generates and runs tests for React components\n */\n\ninterface TestCase {\n  id: string;\n  name: string;\n  type: 'unit' | 'integration' | 'snapshot' | 'accessibility';\n  description: string;\n  code: string;\n  status: 'pending' | 'running' | 'passed' | 'failed' | 'skipped';\n  result?: {\n    passed: boolean;\n    message?: string;\n    duration?: number;\n    errors?: string[];\n  };\n}\n\ninterface TestSuite {\n  id: string;\n  componentName: string;\n  tests: TestCase[];\n  coverage?: {\n    statements: number;\n    branches: number;\n    functions: number;\n    lines: number;\n  };\n  createdAt: number;\n  lastRun?: number;\n}\n\ninterface ComponentTestReport {\n  suite: TestSuite;\n  passed: number;\n  failed: number;\n  skipped: number;\n  duration: number;\n  coverage?: {\n    statements: number;\n    branches: number;\n    functions: number;\n    lines: number;\n  };\n}\n\nexport class TestingFramework {\n  private testSuites: Map<string, TestSuite> = new Map();\n  private testRunner: 'jest' | 'vitest' | 'mocha' = 'jest';\n\n  /**\n   * Generate test suite for a component\n   */\n  generateTestSuite(componentCode: string, componentName?: string): TestSuite {\n    const name = componentName || this.extractComponentName(componentCode);\n    const props = this.extractProps(componentCode);\n    const hooks = this.extractHooks(componentCode);\n    const events = this.extractEvents(componentCode);\n\n    const suite: TestSuite = {\n      id: `suite-${Date.now()}`,\n      componentName: name,\n      tests: [],\n      createdAt: Date.now()\n    };\n\n    // Generate different types of tests\n    suite.tests.push(...this.generateUnitTests(name, props, hooks));\n    suite.tests.push(...this.generateIntegrationTests(name, events));\n    suite.tests.push(...this.generateSnapshotTests(name));\n    suite.tests.push(...this.generateAccessibilityTests(name));\n\n    this.testSuites.set(suite.id, suite);\n    return suite;\n  }\n\n  /**\n   * Generate unit tests\n   */\n  private generateUnitTests(componentName: string, props: string[], hooks: string[]): TestCase[] {\n    const tests: TestCase[] = [];\n\n    // Test component renders\n    tests.push({\n      id: `test-${Date.now()}-render`,\n      name: `${componentName} renders without crashing`,\n      type: 'unit',\n      description: 'Verify component renders without errors',\n      code: `import { render } from '@testing-library/react';\nimport ${componentName} from './${componentName}';\n\ntest('renders without crashing', () => {\n  const { container } = render(<${componentName} />);\n  expect(container).toBeInTheDocument();\n});`,\n      status: 'pending'\n    });\n\n    // Test props\n    props.forEach(prop => {\n      tests.push({\n        id: `test-${Date.now()}-prop-${prop}`,\n        name: `${componentName} handles ${prop} prop correctly`,\n        type: 'unit',\n        description: `Test that ${prop} prop affects component behavior`,\n        code: `import { render, screen } from '@testing-library/react';\nimport ${componentName} from './${componentName}';\n\ntest('handles ${prop} prop', () => {\n  const testValue = 'test-value';\n  const { rerender } = render(<${componentName} ${prop}={testValue} />);\n  \n  // Verify prop is applied\n  // Add specific assertions based on prop type\n  \n  // Test prop changes\n  rerender(<${componentName} ${prop}=\"updated-value\" />);\n  // Verify component updates\n});`,\n        status: 'pending'\n      });\n    });\n\n    // Test hooks\n    hooks.forEach(hook => {\n      tests.push({\n        id: `test-${Date.now()}-hook-${hook}`,\n        name: `${componentName} ${hook} hook works correctly`,\n        type: 'unit',\n        description: `Test ${hook} hook behavior`,\n        code: `import { renderHook, act } from '@testing-library/react';\nimport { ${hook} } from './${componentName}';\n\ntest('${hook} hook behavior', () => {\n  const { result } = renderHook(() => ${hook}());\n  \n  // Test initial state\n  expect(result.current).toBeDefined();\n  \n  // Test hook updates\n  act(() => {\n    // Trigger hook update\n  });\n  \n  // Verify updated state\n});`,\n        status: 'pending'\n      });\n    });\n\n    return tests;\n  }\n\n  /**\n   * Generate integration tests\n   */\n  private generateIntegrationTests(componentName: string, events: string[]): TestCase[] {\n    const tests: TestCase[] = [];\n\n    // Test user interactions\n    events.forEach(event => {\n      tests.push({\n        id: `test-${Date.now()}-event-${event}`,\n        name: `${componentName} handles ${event} event`,\n        type: 'integration',\n        description: `Test ${event} event handler`,\n        code: `import { render, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport ${componentName} from './${componentName}';\n\ntest('handles ${event} event', async () => {\n  const handle${event} = jest.fn();\n  const { container } = render(\n    <${componentName} on${event}={handle${event}} />\n  );\n  \n  const element = container.querySelector('[data-testid=\"${event.toLowerCase()}-target\"]');\n  \n  // Trigger event\n  await userEvent.${event.toLowerCase()}(element);\n  \n  // Verify handler was called\n  await waitFor(() => {\n    expect(handle${event}).toHaveBeenCalled();\n  });\n});`,\n        status: 'pending'\n      });\n    });\n\n    // Test component composition\n    tests.push({\n      id: `test-${Date.now()}-composition`,\n      name: `${componentName} works with other components`,\n      type: 'integration',\n      description: 'Test component composition and integration',\n      code: `import { render, screen } from '@testing-library/react';\nimport ${componentName} from './${componentName}';\nimport ParentComponent from './ParentComponent';\n\ntest('integrates with parent component', () => {\n  render(\n    <ParentComponent>\n      <${componentName} />\n    </ParentComponent>\n  );\n  \n  // Verify component is rendered within parent\n  const component = screen.getByTestId('${componentName.toLowerCase()}');\n  expect(component).toBeInTheDocument();\n  \n  // Test data flow between components\n});`,\n      status: 'pending'\n    });\n\n    return tests;\n  }\n\n  /**\n   * Generate snapshot tests\n   */\n  private generateSnapshotTests(componentName: string): TestCase[] {\n    return [{\n      id: `test-${Date.now()}-snapshot`,\n      name: `${componentName} matches snapshot`,\n      type: 'snapshot',\n      description: 'Verify component rendering consistency',\n      code: `import { render } from '@testing-library/react';\nimport ${componentName} from './${componentName}';\n\ntest('matches snapshot', () => {\n  const { container } = render(<${componentName} />);\n  expect(container.firstChild).toMatchSnapshot();\n});\n\ntest('matches snapshot with props', () => {\n  const { container } = render(\n    <${componentName} \n      title=\"Test Title\"\n      variant=\"primary\"\n      size=\"large\"\n    />\n  );\n  expect(container.firstChild).toMatchSnapshot();\n});`,\n      status: 'pending'\n    }];\n  }\n\n  /**\n   * Generate accessibility tests\n   */\n  private generateAccessibilityTests(componentName: string): TestCase[] {\n    return [{\n      id: `test-${Date.now()}-a11y`,\n      name: `${componentName} meets accessibility standards`,\n      type: 'accessibility',\n      description: 'Test WCAG compliance and accessibility features',\n      code: `import { render } from '@testing-library/react';\nimport { axe, toHaveNoViolations } from 'jest-axe';\nimport ${componentName} from './${componentName}';\n\nexpect.extend(toHaveNoViolations);\n\ntest('has no accessibility violations', async () => {\n  const { container } = render(<${componentName} />);\n  const results = await axe(container);\n  expect(results).toHaveNoViolations();\n});\n\ntest('supports keyboard navigation', () => {\n  const { container } = render(<${componentName} />);\n  \n  // Test tab navigation\n  const focusableElements = container.querySelectorAll(\n    'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n  );\n  \n  focusableElements.forEach(element => {\n    element.focus();\n    expect(document.activeElement).toBe(element);\n  });\n});\n\ntest('has proper ARIA attributes', () => {\n  const { container } = render(<${componentName} />);\n  \n  // Check for required ARIA attributes\n  const interactiveElements = container.querySelectorAll('button, a, input');\n  \n  interactiveElements.forEach(element => {\n    // Verify aria-label or visible text\n    const hasLabel = element.getAttribute('aria-label') || \n                    element.textContent?.trim() ||\n                    element.getAttribute('aria-labelledby');\n    expect(hasLabel).toBeTruthy();\n  });\n});`,\n      status: 'pending'\n    }];\n  }\n\n  /**\n   * Run test suite\n   */\n  async runTestSuite(suiteId: string): Promise<ComponentTestReport> {\n    const suite = this.testSuites.get(suiteId);\n    if (!suite) {\n      throw new Error('Test suite not found');\n    }\n\n    const startTime = Date.now();\n    let passed = 0;\n    let failed = 0;\n    let skipped = 0;\n\n    // Run each test\n    for (const test of suite.tests) {\n      test.status = 'running';\n      \n      try {\n        const result = await this.runTest(test);\n        test.result = result;\n        test.status = result?.passed ? 'passed' : 'failed';\n        \n        if (result?.passed) {\n          passed++;\n        } else {\n          failed++;\n        }\n      } catch (error) {\n        test.status = 'failed';\n        test.result = {\n          passed: false,\n          message: error instanceof Error ? error.message : 'Unknown error',\n          errors: [String(error)]\n        };\n        failed++;\n      }\n    }\n\n    suite.lastRun = Date.now();\n    const duration = Date.now() - startTime;\n\n    // Calculate coverage\n    const coverage = this.calculateCoverage(suite);\n    suite.coverage = coverage;\n\n    return {\n      suite,\n      passed,\n      failed,\n      skipped,\n      duration,\n      coverage\n    };\n  }\n\n  /**\n   * Run individual test (mock implementation)\n   */\n  private async runTest(test: TestCase): Promise<TestCase['result']> {\n    // Simulate test execution\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 100));\n\n    // Mock test results\n    const passed = Math.random() > 0.2; // 80% pass rate\n    \n    return {\n      passed,\n      message: passed ? 'Test passed' : 'Test failed: Assertion error',\n      duration: Math.random() * 100 + 10,\n      errors: passed ? undefined : ['Expected value to be truthy']\n    };\n  }\n\n  /**\n   * Calculate code coverage\n   */\n  private calculateCoverage(suite: TestSuite): TestSuite['coverage'] {\n    // Mock coverage calculation\n    const base = Math.random() * 20 + 70; // 70-90% base coverage\n    \n    return {\n      statements: Math.min(100, base + Math.random() * 10),\n      branches: Math.min(100, base - 5 + Math.random() * 10),\n      functions: Math.min(100, base + 5 + Math.random() * 10),\n      lines: Math.min(100, base + Math.random() * 10)\n    };\n  }\n\n  /**\n   * Generate test report\n   */\n  generateReport(report: ComponentTestReport): string {\n    const { suite, passed, failed, skipped, duration, coverage } = report;\n    \n    return `# Test Report: ${suite.componentName}\n\n## Summary\n- **Total Tests**: ${suite.tests.length}\n- **Passed**: ${passed} ✅\n- **Failed**: ${failed} ❌\n- **Skipped**: ${skipped} ⏭️\n- **Duration**: ${(duration / 1000).toFixed(2)}s\n\n## Coverage\n${coverage ? `\n- Statements: ${coverage.statements.toFixed(1)}%\n- Branches: ${coverage.branches.toFixed(1)}%\n- Functions: ${coverage.functions.toFixed(1)}%\n- Lines: ${coverage.lines.toFixed(1)}%\n` : 'No coverage data available'}\n\n## Test Results\n\n${suite.tests.map(test => `\n### ${test.name}\n- **Type**: ${test.type}\n- **Status**: ${test.status} ${this.getStatusEmoji(test.status)}\n- **Duration**: ${test.result?.duration?.toFixed(0) || 0}ms\n${test.result?.message ? `- **Message**: ${test.result.message}` : ''}\n${test.result?.errors ? `- **Errors**: \\n  ${test.result.errors.join('\\n  ')}` : ''}\n`).join('\\n')}\n\n---\nGenerated at: ${new Date(suite.lastRun || Date.now()).toLocaleString()}\n`;\n  }\n\n  /**\n   * Get status emoji\n   */\n  private getStatusEmoji(status: TestCase['status']): string {\n    switch (status) {\n      case 'passed': return '✅';\n      case 'failed': return '❌';\n      case 'running': return '🔄';\n      case 'skipped': return '⏭️';\n      default: return '⏸️';\n    }\n  }\n\n  /**\n   * Extract component name from code\n   */\n  private extractComponentName(code: string): string {\n    const match = code.match(/(?:const|function|class)\\s+(\\w+)/);\n    return match ? match[1] : 'Component';\n  }\n\n  /**\n   * Extract props from component code\n   */\n  private extractProps(code: string): string[] {\n    const props: string[] = [];\n    const propsMatch = code.match(/\\(?\\s*{\\s*([^}]+)\\s*}\\s*\\)?/);\n    \n    if (propsMatch) {\n      const propsString = propsMatch[1];\n      const propNames = propsString.split(',').map(p => p.trim().split(/[=:]/)[0]);\n      props.push(...propNames.filter(Boolean));\n    }\n    \n    return props;\n  }\n\n  /**\n   * Extract hooks from component code\n   */\n  private extractHooks(code: string): string[] {\n    const hooks: string[] = [];\n    const hookPattern = /use\\w+/g;\n    const matches = code.match(hookPattern);\n    \n    if (matches) {\n      hooks.push(...Array.from(new Set(matches)));\n    }\n    \n    return hooks;\n  }\n\n  /**\n   * Extract event handlers from component code\n   */\n  private extractEvents(code: string): string[] {\n    const events: string[] = [];\n    const eventPattern = /on[A-Z]\\w+/g;\n    const matches = code.match(eventPattern);\n    \n    if (matches) {\n      const eventNames = matches.map(e => e.replace(/^on/, ''));\n      events.push(...Array.from(new Set(eventNames)));\n    }\n    \n    return events;\n  }\n\n  /**\n   * Export test suite to file\n   */\n  exportTestFile(suiteId: string): string {\n    const suite = this.testSuites.get(suiteId);\n    if (!suite) {\n      throw new Error('Test suite not found');\n    }\n\n    const imports = this.generateImports(suite);\n    const tests = suite.tests.map(test => test.code).join('\\n\\n');\n\n    return `${imports}\n\ndescribe('${suite.componentName}', () => {\n${tests.split('\\n').map(line => '  ' + line).join('\\n')}\n});`;\n  }\n\n  /**\n   * Generate import statements\n   */\n  private generateImports(suite: TestSuite): string {\n    const imports = new Set<string>();\n    \n    // Add common testing library imports\n    imports.add(\"import { render, screen, fireEvent, waitFor } from '@testing-library/react';\");\n    imports.add(\"import userEvent from '@testing-library/user-event';\");\n    \n    // Add component import\n    imports.add(`import ${suite.componentName} from './${suite.componentName}';`);\n    \n    // Check for specific test types\n    const hasAccessibilityTests = suite.tests.some(t => t.type === 'accessibility');\n    if (hasAccessibilityTests) {\n      imports.add(\"import { axe, toHaveNoViolations } from 'jest-axe';\");\n    }\n    \n    const hasHookTests = suite.tests.some(t => t.code.includes('renderHook'));\n    if (hasHookTests) {\n      imports.add(\"import { renderHook, act } from '@testing-library/react';\");\n    }\n    \n    return Array.from(imports).join('\\n');\n  }\n}\n\nexport default TestingFramework;"],"names":["constructor","testSuites","Map","testRunner","generateTestSuite","componentCode","componentName","name","this","extractComponentName","props","extractProps","hooks","extractHooks","events","extractEvents","suite","id","Date","now","tests","createdAt","push","generateUnitTests","generateIntegrationTests","generateSnapshotTests","generateAccessibilityTests","set","type","description","code","status","forEach","prop","hook","event","toLowerCase","runTestSuite","suiteId","get","Error","startTime","passed","failed","test","result","runTest","error","message","errors","String","lastRun","duration","coverage","calculateCoverage","skipped","Promise","resolve","setTimeout","Math","random","undefined","base","statements","min","branches","functions","lines","generateReport","report","length","toFixed","map","_test$result","_test$result$duration","_test$result2","_test$result3","getStatusEmoji","join","toLocaleString","match","propsMatch","propNames","split","p","trim","filter","Boolean","matches","Array","from","Set","eventNames","e","replace","exportTestFile","imports","generateImports","line","add","some","t","includes"],"sourceRoot":""}