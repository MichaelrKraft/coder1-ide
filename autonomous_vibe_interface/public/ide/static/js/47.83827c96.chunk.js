"use strict";(self.webpackChunkcoder1_ide_source=self.webpackChunkcoder1_ide_source||[]).push([[47],{3047:(e,t,n)=>{n.d(t,{default:()=>s});const s=class{constructor(){this.testSuites=new Map,this.testRunner="jest"}generateTestSuite(e,t){const n=t||this.extractComponentName(e),s=this.extractProps(e),r=this.extractHooks(e),o=this.extractEvents(e),a={id:`suite-${Date.now()}`,componentName:n,tests:[],createdAt:Date.now()};return a.tests.push(...this.generateUnitTests(n,s,r)),a.tests.push(...this.generateIntegrationTests(n,o)),a.tests.push(...this.generateSnapshotTests(n)),a.tests.push(...this.generateAccessibilityTests(n)),this.testSuites.set(a.id,a),a}generateUnitTests(e,t,n){const s=[];return s.push({id:`test-${Date.now()}-render`,name:`${e} renders without crashing`,type:"unit",description:"Verify component renders without errors",code:`import { render } from '@testing-library/react';\nimport ${e} from './${e}';\n\ntest('renders without crashing', () => {\n  const { container } = render(<${e} />);\n  expect(container).toBeInTheDocument();\n});`,status:"pending"}),t.forEach(t=>{s.push({id:`test-${Date.now()}-prop-${t}`,name:`${e} handles ${t} prop correctly`,type:"unit",description:`Test that ${t} prop affects component behavior`,code:`import { render, screen } from '@testing-library/react';\nimport ${e} from './${e}';\n\ntest('handles ${t} prop', () => {\n  const testValue = 'test-value';\n  const { rerender } = render(<${e} ${t}={testValue} />);\n  \n  // Verify prop is applied\n  // Add specific assertions based on prop type\n  \n  // Test prop changes\n  rerender(<${e} ${t}="updated-value" />);\n  // Verify component updates\n});`,status:"pending"})}),n.forEach(t=>{s.push({id:`test-${Date.now()}-hook-${t}`,name:`${e} ${t} hook works correctly`,type:"unit",description:`Test ${t} hook behavior`,code:`import { renderHook, act } from '@testing-library/react';\nimport { ${t} } from './${e}';\n\ntest('${t} hook behavior', () => {\n  const { result } = renderHook(() => ${t}());\n  \n  // Test initial state\n  expect(result.current).toBeDefined();\n  \n  // Test hook updates\n  act(() => {\n    // Trigger hook update\n  });\n  \n  // Verify updated state\n});`,status:"pending"})}),s}generateIntegrationTests(e,t){const n=[];return t.forEach(t=>{n.push({id:`test-${Date.now()}-event-${t}`,name:`${e} handles ${t} event`,type:"integration",description:`Test ${t} event handler`,code:`import { render, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport ${e} from './${e}';\n\ntest('handles ${t} event', async () => {\n  const handle${t} = jest.fn();\n  const { container } = render(\n    <${e} on${t}={handle${t}} />\n  );\n  \n  const element = container.querySelector('[data-testid="${t.toLowerCase()}-target"]');\n  \n  // Trigger event\n  await userEvent.${t.toLowerCase()}(element);\n  \n  // Verify handler was called\n  await waitFor(() => {\n    expect(handle${t}).toHaveBeenCalled();\n  });\n});`,status:"pending"})}),n.push({id:`test-${Date.now()}-composition`,name:`${e} works with other components`,type:"integration",description:"Test component composition and integration",code:`import { render, screen } from '@testing-library/react';\nimport ${e} from './${e}';\nimport ParentComponent from './ParentComponent';\n\ntest('integrates with parent component', () => {\n  render(\n    <ParentComponent>\n      <${e} />\n    </ParentComponent>\n  );\n  \n  // Verify component is rendered within parent\n  const component = screen.getByTestId('${e.toLowerCase()}');\n  expect(component).toBeInTheDocument();\n  \n  // Test data flow between components\n});`,status:"pending"}),n}generateSnapshotTests(e){return[{id:`test-${Date.now()}-snapshot`,name:`${e} matches snapshot`,type:"snapshot",description:"Verify component rendering consistency",code:`import { render } from '@testing-library/react';\nimport ${e} from './${e}';\n\ntest('matches snapshot', () => {\n  const { container } = render(<${e} />);\n  expect(container.firstChild).toMatchSnapshot();\n});\n\ntest('matches snapshot with props', () => {\n  const { container } = render(\n    <${e} \n      title="Test Title"\n      variant="primary"\n      size="large"\n    />\n  );\n  expect(container.firstChild).toMatchSnapshot();\n});`,status:"pending"}]}generateAccessibilityTests(e){return[{id:`test-${Date.now()}-a11y`,name:`${e} meets accessibility standards`,type:"accessibility",description:"Test WCAG compliance and accessibility features",code:`import { render } from '@testing-library/react';\nimport { axe, toHaveNoViolations } from 'jest-axe';\nimport ${e} from './${e}';\n\nexpect.extend(toHaveNoViolations);\n\ntest('has no accessibility violations', async () => {\n  const { container } = render(<${e} />);\n  const results = await axe(container);\n  expect(results).toHaveNoViolations();\n});\n\ntest('supports keyboard navigation', () => {\n  const { container } = render(<${e} />);\n  \n  // Test tab navigation\n  const focusableElements = container.querySelectorAll(\n    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'\n  );\n  \n  focusableElements.forEach(element => {\n    element.focus();\n    expect(document.activeElement).toBe(element);\n  });\n});\n\ntest('has proper ARIA attributes', () => {\n  const { container } = render(<${e} />);\n  \n  // Check for required ARIA attributes\n  const interactiveElements = container.querySelectorAll('button, a, input');\n  \n  interactiveElements.forEach(element => {\n    // Verify aria-label or visible text\n    const hasLabel = element.getAttribute('aria-label') || \n                    element.textContent?.trim() ||\n                    element.getAttribute('aria-labelledby');\n    expect(hasLabel).toBeTruthy();\n  });\n});`,status:"pending"}]}async runTestSuite(e){const t=this.testSuites.get(e);if(!t)throw new Error("Test suite not found");const n=Date.now();let s=0,r=0;for(const c of t.tests){c.status="running";try{const e=await this.runTest(c);c.result=e,c.status=null!==e&&void 0!==e&&e.passed?"passed":"failed",null!==e&&void 0!==e&&e.passed?s++:r++}catch(i){c.status="failed",c.result={passed:!1,message:i instanceof Error?i.message:"Unknown error",errors:[String(i)]},r++}}t.lastRun=Date.now();const o=Date.now()-n,a=this.calculateCoverage(t);return t.coverage=a,{suite:t,passed:s,failed:r,skipped:0,duration:o,coverage:a}}async runTest(e){await new Promise(e=>setTimeout(e,500*Math.random()+100));const t=Math.random()>.2;return{passed:t,message:t?"Test passed":"Test failed: Assertion error",duration:100*Math.random()+10,errors:t?void 0:["Expected value to be truthy"]}}calculateCoverage(e){const t=20*Math.random()+70;return{statements:Math.min(100,t+10*Math.random()),branches:Math.min(100,t-5+10*Math.random()),functions:Math.min(100,t+5+10*Math.random()),lines:Math.min(100,t+10*Math.random())}}generateReport(e){const{suite:t,passed:n,failed:s,skipped:r,duration:o,coverage:a}=e;return`# Test Report: ${t.componentName}\n\n## Summary\n- **Total Tests**: ${t.tests.length}\n- **Passed**: ${n} \u2705\n- **Failed**: ${s} \u274c\n- **Skipped**: ${r} \u23ed\ufe0f\n- **Duration**: ${(o/1e3).toFixed(2)}s\n\n## Coverage\n${a?`\n- Statements: ${a.statements.toFixed(1)}%\n- Branches: ${a.branches.toFixed(1)}%\n- Functions: ${a.functions.toFixed(1)}%\n- Lines: ${a.lines.toFixed(1)}%\n`:"No coverage data available"}\n\n## Test Results\n\n${t.tests.map(e=>{var t,n,s,r;return`\n### ${e.name}\n- **Type**: ${e.type}\n- **Status**: ${e.status} ${this.getStatusEmoji(e.status)}\n- **Duration**: ${(null===(t=e.result)||void 0===t||null===(n=t.duration)||void 0===n?void 0:n.toFixed(0))||0}ms\n${null!==(s=e.result)&&void 0!==s&&s.message?`- **Message**: ${e.result.message}`:""}\n${null!==(r=e.result)&&void 0!==r&&r.errors?`- **Errors**: \n  ${e.result.errors.join("\n  ")}`:""}\n`}).join("\n")}\n\n---\nGenerated at: ${new Date(t.lastRun||Date.now()).toLocaleString()}\n`}getStatusEmoji(e){switch(e){case"passed":return"\u2705";case"failed":return"\u274c";case"running":return"\ud83d\udd04";case"skipped":return"\u23ed\ufe0f";default:return"\u23f8\ufe0f"}}extractComponentName(e){const t=e.match(/(?:const|function|class)\s+(\w+)/);return t?t[1]:"Component"}extractProps(e){const t=[],n=e.match(/\(?\s*{\s*([^}]+)\s*}\s*\)?/);if(n){const e=n[1].split(",").map(e=>e.trim().split(/[=:]/)[0]);t.push(...e.filter(Boolean))}return t}extractHooks(e){const t=[],n=e.match(/use\w+/g);return n&&t.push(...Array.from(new Set(n))),t}extractEvents(e){const t=[],n=e.match(/on[A-Z]\w+/g);if(n){const e=n.map(e=>e.replace(/^on/,""));t.push(...Array.from(new Set(e)))}return t}exportTestFile(e){const t=this.testSuites.get(e);if(!t)throw new Error("Test suite not found");const n=this.generateImports(t),s=t.tests.map(e=>e.code).join("\n\n");return`${n}\n\ndescribe('${t.componentName}', () => {\n${s.split("\n").map(e=>"  "+e).join("\n")}\n});`}generateImports(e){const t=new Set;t.add("import { render, screen, fireEvent, waitFor } from '@testing-library/react';"),t.add("import userEvent from '@testing-library/user-event';"),t.add(`import ${e.componentName} from './${e.componentName}';`);e.tests.some(e=>"accessibility"===e.type)&&t.add("import { axe, toHaveNoViolations } from 'jest-axe';");return e.tests.some(e=>e.code.includes("renderHook"))&&t.add("import { renderHook, act } from '@testing-library/react';"),Array.from(t).join("\n")}}}}]);
//# sourceMappingURL=47.83827c96.chunk.js.map