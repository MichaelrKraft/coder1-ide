/**
 * Session Checkpoints Service
 * Manages conversation/session state snapshots for easy restoration
 */

import { API_ENDPOINTS, apiRequest } from '../config/api';

export interface Checkpoint {
  id: string;
  sessionId: string;
  name: string;
  description?: string;
  timestamp: number;
  data: CheckpointData;
  metadata: CheckpointMetadata;
}

export interface CheckpointData {
  // Conversation state
  messages: ChatMessage[];
  currentContext: string;
  activeFiles: string[];
  
  // Editor state
  editorContent?: Record<string, string>; // filepath -> content
  cursorPositions?: Record<string, CursorPosition>;
  
  // AI state
  thinkingMode: string;
  selectedModel?: string;
  systemPrompt?: string;
  
  // UI state
  activeView: string;
  sidebarCollapsed: boolean;
  terminalVisible: boolean;
  
  // Project state
  projectFiles: string[];
  modifiedFiles: string[];
  gitBranch?: string;
  gitCommit?: string;
}

export interface CheckpointMetadata {
  version: string;
  userAgent: string;
  timestamp: number;
  size: number; // bytes
  hash: string; // for integrity checking
  tags: string[];
  autoGenerated: boolean;
}

export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
  metadata?: Record<string, any>;
}

export interface CursorPosition {
  line: number;
  column: number;
  selection?: {
    start: { line: number; column: number };
    end: { line: number; column: number };
  };
}

export interface SessionInfo {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  updatedAt: number;
  checkpointCount: number;
  lastCheckpoint?: Checkpoint;
}

export class CheckpointService {
  private readonly LOCAL_STORAGE_KEY = 'coder1-checkpoints';
  private readonly MAX_LOCAL_CHECKPOINTS = 50;
  
  /**
   * Create a new checkpoint
   */
  async createCheckpoint(
    sessionId: string,
    name: string,
    data: CheckpointData,
    description?: string,
    tags: string[] = []
  ): Promise<Checkpoint> {
    const checkpoint: Checkpoint = {
      id: this.generateId(),
      sessionId,
      name,
      description,
      timestamp: Date.now(),
      data,
      metadata: {
        version: '1.0',
        userAgent: navigator.userAgent,
        timestamp: Date.now(),
        size: this.calculateSize(data),
        hash: await this.calculateHash(data),
        tags,
        autoGenerated: false,
      },
    };

    // Save to backend if available
    try {
      const response = await fetch(API_ENDPOINTS.SESSIONS.CHECKPOINT(sessionId), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          name: checkpoint.name,
          description: checkpoint.description,
          data: checkpoint.data,
          metadata: checkpoint.metadata,
          autoGenerated: checkpoint.metadata.autoGenerated,
          tags: checkpoint.metadata.tags
        }),
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('✅ Checkpoint saved to backend:', result.checkpoint?.id);
        // Emit event for UI updates
        window.dispatchEvent(new CustomEvent('checkpointCreated', { detail: { checkpoint: result.checkpoint } }));
      } else {
        console.warn('⚠️ Failed to save checkpoint to backend:', response.status, response.statusText);
      }
    } catch (error) {
      console.warn('Failed to save checkpoint to backend, using local storage:', error);
    }

    // Always save to local storage as backup
    this.saveToLocalStorage(checkpoint);
    
    return checkpoint;
  }

  /**
   * Get all checkpoints for a session
   */
  async getCheckpoints(sessionId: string): Promise<Checkpoint[]> {
    try {
      // Try backend first
      const response = await apiRequest(`${API_ENDPOINTS.SESSIONS.GET(sessionId)}/checkpoints`);
      if (response.success) {
        return response.checkpoints || [];
      }
    } catch (error) {
      console.warn('Failed to fetch checkpoints from backend, using local storage:', error);
    }

    // Fallback to local storage
    return this.getFromLocalStorage().filter(cp => cp.sessionId === sessionId);
  }

  /**
   * Get a specific checkpoint
   */
  async getCheckpoint(sessionId: string, checkpointId: string): Promise<Checkpoint | null> {
    try {
      // Try backend first
      const response = await apiRequest(`${API_ENDPOINTS.SESSIONS.GET(sessionId)}/checkpoints/${checkpointId}`);
      if (response.success) {
        return response.checkpoint;
      }
    } catch (error) {
      console.warn('Failed to fetch checkpoint from backend, using local storage:', error);
    }

    // Fallback to local storage
    const checkpoints = this.getFromLocalStorage();
    return checkpoints.find(cp => cp.id === checkpointId && cp.sessionId === sessionId) || null;
  }

  /**
   * Delete a checkpoint
   */
  async deleteCheckpoint(sessionId: string, checkpointId: string): Promise<void> {
    try {
      await apiRequest(`${API_ENDPOINTS.SESSIONS.GET(sessionId)}/checkpoints/${checkpointId}`, {
        method: 'DELETE',
      });
    } catch (error) {
      console.warn('Failed to delete checkpoint from backend:', error);
    }

    // Remove from local storage
    const checkpoints = this.getFromLocalStorage();
    const filtered = checkpoints.filter(cp => cp.id !== checkpointId);
    this.saveAllToLocalStorage(filtered);
  }

  /**
   * Create an automatic checkpoint
   */
  async createAutoCheckpoint(sessionId: string, data: CheckpointData): Promise<Checkpoint> {
    const timestamp = new Date().toLocaleTimeString();
    const checkpoint = await this.createCheckpoint(
      sessionId,
      `Auto Checkpoint ${timestamp}`,
      data,
      'Automatically generated checkpoint',
      ['auto']
    );
    
    checkpoint.metadata.autoGenerated = true;
    return checkpoint;
  }

  /**
   * Compare two checkpoints
   */
  compareCheckpoints(checkpoint1: Checkpoint, checkpoint2: Checkpoint): CheckpointDiff {
    return {
      messages: this.compareArrays(checkpoint1.data.messages, checkpoint2.data.messages),
      files: this.compareArrays(checkpoint1.data.activeFiles, checkpoint2.data.activeFiles),
      editorChanges: this.compareObjects(
        checkpoint1.data.editorContent || {},
        checkpoint2.data.editorContent || {}
      ),
      settingsChanges: {
        thinkingMode: checkpoint1.data.thinkingMode !== checkpoint2.data.thinkingMode,
        activeView: checkpoint1.data.activeView !== checkpoint2.data.activeView,
      },
      timestamp: {
        from: checkpoint1.timestamp,
        to: checkpoint2.timestamp,
        duration: checkpoint2.timestamp - checkpoint1.timestamp,
      },
    };
  }

  /**
   * Export checkpoints
   */
  async exportCheckpoints(sessionId: string): Promise<string> {
    const checkpoints = await this.getCheckpoints(sessionId);
    return JSON.stringify({
      version: '1.0',
      sessionId,
      exportedAt: Date.now(),
      checkpoints,
    }, null, 2);
  }

  /**
   * Import checkpoints
   */
  async importCheckpoints(jsonData: string): Promise<Checkpoint[]> {
    try {
      const data = JSON.parse(jsonData);
      const checkpoints: Checkpoint[] = data.checkpoints || [];
      
      // Validate and save each checkpoint
      const imported: Checkpoint[] = [];
      for (const checkpoint of checkpoints) {
        if (this.validateCheckpoint(checkpoint)) {
          // Update timestamp to avoid conflicts
          checkpoint.id = this.generateId();
          checkpoint.timestamp = Date.now();
          
          this.saveToLocalStorage(checkpoint);
          imported.push(checkpoint);
        }
      }
      
      return imported;
    } catch (error) {
      throw new Error('Invalid checkpoint data format');
    }
  }

  // Private methods
  
  private generateId(): string {
    return `checkpoint_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private calculateSize(data: CheckpointData): number {
    return new Blob([JSON.stringify(data)]).size;
  }

  private async calculateHash(data: CheckpointData): Promise<string> {
    const str = JSON.stringify(data);
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(str);
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }

  private getFromLocalStorage(): Checkpoint[] {
    try {
      const stored = localStorage.getItem(this.LOCAL_STORAGE_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.error('Failed to load checkpoints from local storage:', error);
      return [];
    }
  }

  private saveToLocalStorage(checkpoint: Checkpoint): void {
    const checkpoints = this.getFromLocalStorage();
    checkpoints.push(checkpoint);
    
    // Maintain size limit
    if (checkpoints.length > this.MAX_LOCAL_CHECKPOINTS) {
      checkpoints.sort((a, b) => b.timestamp - a.timestamp);
      checkpoints.splice(this.MAX_LOCAL_CHECKPOINTS);
    }
    
    this.saveAllToLocalStorage(checkpoints);
  }

  private saveAllToLocalStorage(checkpoints: Checkpoint[]): void {
    try {
      localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(checkpoints));
    } catch (error) {
      console.error('Failed to save checkpoints to local storage:', error);
    }
  }

  private validateCheckpoint(checkpoint: any): boolean {
    return (
      checkpoint &&
      typeof checkpoint.id === 'string' &&
      typeof checkpoint.sessionId === 'string' &&
      typeof checkpoint.name === 'string' &&
      typeof checkpoint.timestamp === 'number' &&
      checkpoint.data &&
      checkpoint.metadata
    );
  }

  private compareArrays<T>(arr1: T[], arr2: T[]): { added: T[]; removed: T[]; unchanged: T[] } {
    const set1 = new Set(arr1);
    const set2 = new Set(arr2);
    
    return {
      added: arr2.filter(item => !set1.has(item)),
      removed: arr1.filter(item => !set2.has(item)),
      unchanged: arr1.filter(item => set2.has(item)),
    };
  }

  private compareObjects(obj1: Record<string, any>, obj2: Record<string, any>): Record<string, 'added' | 'removed' | 'changed'> {
    const result: Record<string, 'added' | 'removed' | 'changed'> = {};
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    const allKeys = Array.from(new Set([...keys1, ...keys2]));
    
    for (let i = 0; i < allKeys.length; i++) {
      const key = allKeys[i];
      if (!(key in obj1)) {
        result[key] = 'added';
      } else if (!(key in obj2)) {
        result[key] = 'removed';
      } else if (obj1[key] !== obj2[key]) {
        result[key] = 'changed';
      }
    }
    
    return result;
  }
}

export interface CheckpointDiff {
  messages: { added: ChatMessage[]; removed: ChatMessage[]; unchanged: ChatMessage[] };
  files: { added: string[]; removed: string[]; unchanged: string[] };
  editorChanges: Record<string, 'added' | 'removed' | 'changed'>;
  settingsChanges: {
    thinkingMode: boolean;
    activeView: boolean;
  };
  timestamp: {
    from: number;
    to: number;
    duration: number;
  };
}

// Singleton instance
export const checkpointService = new CheckpointService();