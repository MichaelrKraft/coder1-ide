/**
 * SessionHistoryPanel Component
 * 
 * Professional session management panel with clean UI
 */

import React, { useState, useEffect } from 'react';
import './SessionHistoryPanel.css';
import { API_ENDPOINTS } from '../config/api';

interface Session {
  id: string;
  name: string;
  description: string;
  createdAt: number;
  updatedAt: number;
  metadata?: {
    filesCount?: number;
    terminalActive?: boolean;
    aiModesActive?: string[];
  };
}

interface Checkpoint {
  id: string;
  sessionId: string;
  name: string;
  description: string;
  timestamp: number;
  metadata?: {
    autoGenerated?: boolean;
    size?: number;
  };
}

interface SessionHistoryPanelProps {
  onSessionRestore?: (sessionId: string) => void;
  onCheckpointRestore?: (sessionId: string, checkpointId: string) => void;
  currentSessionId?: string;
}

export const SessionHistoryPanel: React.FC<SessionHistoryPanelProps> = ({
  onSessionRestore,
  onCheckpointRestore,
  currentSessionId
}) => {
  const [sessions, setSessions] = useState<Session[]>([]);
  const [checkpoints, setCheckpoints] = useState<Record<string, Checkpoint[]>>({});
  const [expandedSession, setExpandedSession] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [autoCheckpointInterval, setAutoCheckpointInterval] = useState<NodeJS.Timeout | null>(null);

  // Fetch sessions from backend
  useEffect(() => {
    fetchSessions();
    
    // Start auto-checkpointing for current session
    if (currentSessionId) {
      startAutoCheckpointing(currentSessionId);
    }
    
    // Set up refresh interval to catch new sessions
    const refreshInterval = setInterval(() => {
      fetchSessions();
    }, 5000); // Refresh every 5 seconds
    
    // Listen for checkpoint creation events
    const handleCheckpointCreated = () => {
      console.log('üìå Checkpoint created event received, refreshing...');
      fetchSessions();
      if (expandedSession && currentSessionId) {
        fetchCheckpoints(currentSessionId);
      }
    };
    
    window.addEventListener('checkpointCreated', handleCheckpointCreated);
    
    return () => {
      if (autoCheckpointInterval) {
        clearInterval(autoCheckpointInterval);
      }
      clearInterval(refreshInterval);
      window.removeEventListener('checkpointCreated', handleCheckpointCreated);
    };
  }, [currentSessionId, expandedSession]);

  const startAutoCheckpointing = (sessionId: string) => {
    // Clear existing interval
    if (autoCheckpointInterval) {
      clearInterval(autoCheckpointInterval);
    }
    
    // DISABLED: Auto-checkpoint creation causing 429 errors
    console.warn('Auto-checkpoint creation disabled due to 429 flooding');
    const interval = null as any;
    
    /* ORIGINAL CODE - DISABLED
    // Create checkpoint every 5 minutes
    const interval = setInterval(async () => {
      try {
        const response = await fetch(API_ENDPOINTS.SESSIONS.CHECKPOINT(sessionId), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: `Auto-save ${new Date().toLocaleTimeString()}`,
            description: 'Automatic checkpoint',
            autoGenerated: true,
            data: {
              timestamp: Date.now()
            }
          })
        });
        
        if (response.ok) {
          console.log('‚úÖ Auto-checkpoint created');
          // Refresh checkpoints if this session is expanded
          if (expandedSession === sessionId) {
            fetchCheckpoints(sessionId);
          }
        }
      } catch (err) {
        console.error('Failed to create auto-checkpoint:', err);
      }
    }, 5 * 60 * 1000); // 5 minutes
    */
    
    setAutoCheckpointInterval(interval);
  };

  const fetchSessions = async () => {
    try {
      setLoading(true);
      const response = await fetch(API_ENDPOINTS.SESSIONS.LIST);
      if (!response.ok) throw new Error('Failed to fetch sessions');
      
      const data = await response.json();
      setSessions(data.sessions || []);
      setError(null);
    } catch (err) {
      console.error('Failed to fetch sessions:', err);
      setError('Unable to load sessions');
    } finally {
      setLoading(false);
    }
  };

  const fetchCheckpoints = async (sessionId: string) => {
    // DISABLED: Checkpoint fetching causing 429 errors and browser flooding
    console.warn('Checkpoint fetching disabled due to 429 flooding');
    return;
    
    /* ORIGINAL CODE - DISABLED
    try {
      const response = await fetch(`${API_ENDPOINTS.SESSIONS.GET(sessionId)}/checkpoints`);
      if (!response.ok) throw new Error('Failed to fetch checkpoints');
      
      const data = await response.json();
      setCheckpoints(prev => ({
        ...prev,
        [sessionId]: data.checkpoints || []
      }));
    } catch (err) {
      console.error('Failed to fetch checkpoints:', err);
    }
    */
  };

  const handleSessionClick = async (sessionId: string) => {
    if (expandedSession === sessionId) {
      setExpandedSession(null);
    } else {
      setExpandedSession(sessionId);
      if (!checkpoints[sessionId]) {
        await fetchCheckpoints(sessionId);
      }
    }
  };

  const handleSessionRestore = async (sessionId: string, event: React.MouseEvent) => {
    event.stopPropagation();
    if (!onSessionRestore) return;
    
    try {
      const response = await fetch(API_ENDPOINTS.SESSIONS.GET(sessionId));
      if (!response.ok) throw new Error('Failed to fetch session data');
      
      onSessionRestore(sessionId);
    } catch (err) {
      console.error('Failed to restore session:', err);
    }
  };

  const handleCheckpointRestore = async (sessionId: string, checkpointId: string) => {
    if (!onCheckpointRestore) return;
    
    try {
      const response = await fetch(API_ENDPOINTS.SESSIONS.RESTORE(sessionId, checkpointId), {
        method: 'POST'
      });
      if (!response.ok) throw new Error('Failed to restore checkpoint');
      
      onCheckpointRestore(sessionId, checkpointId);
    } catch (err) {
      console.error('Failed to restore checkpoint:', err);
    }
  };

  const handleSessionDelete = async (sessionId: string, event: React.MouseEvent) => {
    event.stopPropagation();
    
    if (!window.confirm('Delete this session and all its checkpoints?')) {
      return;
    }

    try {
      const response = await fetch(API_ENDPOINTS.SESSIONS.DELETE(sessionId), {
        method: 'DELETE'
      });
      if (!response.ok) throw new Error('Failed to delete session');
      
      await fetchSessions();
      
      if (expandedSession === sessionId) {
        setExpandedSession(null);
      }
    } catch (err) {
      console.error('Failed to delete session:', err);
    }
  };

  const formatTime = (timestamp: number): string => {
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / (1000 * 60));
    
    if (diffMins < 1) return 'just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    
    const diffHours = Math.floor(diffMins / 60);
    if (diffHours < 24) return `${diffHours}h ago`;
    
    const diffDays = Math.floor(diffHours / 24);
    return `${diffDays}d ago`;
  };

  if (loading) {
    return (
      <div className="session-history-panel">
        <div className="session-panel-header">
          <span className="header-title">SESSIONS</span>
          <button className="header-refresh" onClick={fetchSessions} title="Refresh">
            ‚Üª
          </button>
        </div>
        <div className="session-loading">
          Loading...
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="session-history-panel">
        <div className="session-panel-header">
          <span className="header-title">SESSIONS</span>
        </div>
        <div className="session-error">
          {error}
        </div>
      </div>
    );
  }

  return (
    <div className="session-history-panel">
      <div className="session-panel-header">
        <span className="header-title">SESSIONS</span>
        <button className="header-refresh" onClick={fetchSessions} title="Refresh">
          ‚Üª
        </button>
      </div>

      <div className="sessions-container">
        {sessions.length === 0 ? (
          <div className="empty-state">
            <div className="empty-icon">üìÇ</div>
            <div className="empty-text">No sessions yet</div>
            <div className="empty-hint">Sessions will appear here</div>
          </div>
        ) : (
          sessions.map(session => {
            const isExpanded = expandedSession === session.id;
            const isCurrent = session.id === currentSessionId;
            
            return (
              <div key={session.id} className={`session-group ${isCurrent ? 'current' : ''}`}>
                <div 
                  className={`session-row ${isExpanded ? 'expanded' : ''}`}
                  onClick={() => handleSessionClick(session.id)}
                >
                  <div className="session-content">
                    <div className="session-main">
                      <span className="session-chevron">
                        {isExpanded ? '‚åÑ' : '‚Ä∫'}
                      </span>
                      <div className="session-details">
                        <div className="session-title" title={session.name.replace('Test Session from Coder1', 'Current Session')}>
                          {isCurrent && <span className="current-indicator">‚óè</span>}
                          <span className="session-name">
                            {isCurrent ? 'Current' : `Session ${sessions.indexOf(session) + 1}`}
                          </span>
                        </div>
                      </div>
                    </div>
                    
                    <div className="session-meta">
                      <span className="session-time">{formatTime(session.updatedAt)}</span>
                      <div className="session-actions">
                        {!isCurrent && (
                          <button
                            className="action-btn restore"
                            onClick={(e) => handleSessionRestore(session.id, e)}
                            title="Restore session"
                          >
                            ‚Ü∫
                          </button>
                        )}
                        <button
                          className="action-btn delete"
                          onClick={(e) => handleSessionDelete(session.id, e)}
                          disabled={isCurrent}
                          title="Delete session"
                        >
                          <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                            <path d="M6.5 1.75a.25.25 0 01.25-.25h2.5a.25.25 0 01.25.25V3h-3V1.75zm4.5 0V3h2.25a.75.75 0 010 1.5H2.75a.75.75 0 010-1.5H5V1.75C5 .784 5.784 0 6.75 0h2.5C10.216 0 11 .784 11 1.75zM4.496 6.675a.75.75 0 10-1.492.15l.66 6.6A1.75 1.75 0 005.405 15h5.19c.9 0 1.652-.681 1.741-1.576l.66-6.6a.75.75 0 00-1.492-.149l-.66 6.6a.25.25 0 01-.249.225h-5.19a.25.25 0 01-.249-.225l-.66-6.6z"/>
                          </svg>
                        </button>
                      </div>
                    </div>
                  </div>
                </div>

                {isExpanded && (
                  <div className="checkpoints-container">
                    {checkpoints[session.id]?.length > 0 ? (
                      <>
                        <div className="checkpoints-header">
                          <span className="checkpoints-label">Saves</span>
                          <span className="checkpoints-count">{checkpoints[session.id].length}</span>
                        </div>
                        <div className="checkpoint-list">
                          {checkpoints[session.id].map(checkpoint => (
                            <div key={checkpoint.id} className="checkpoint-row">
                              <div className="checkpoint-column">
                                <div className="checkpoint-type">
                                  {checkpoint.metadata?.autoGenerated ? 'Auto' : 'Manual'}
                                </div>
                                <button
                                  className="checkpoint-restore"
                                  onClick={() => handleCheckpointRestore(session.id, checkpoint.id)}
                                  title={checkpoint.name}
                                >
                                  Restore
                                </button>
                                <div className="checkpoint-time">{formatTime(checkpoint.timestamp)}</div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </>
                    ) : (
                      <div className="checkpoints-empty">
                        No checkpoints saved
                      </div>
                    )}
                  </div>
                )}
              </div>
            );
          })
        )}
      </div>
    </div>
  );
};

export default SessionHistoryPanel;