{
  "devDependencies": {
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "cypress": "^12.5.1",
    "jest": "^29.4.1",
    "jest-environment-jsdom": "^29.4.1",
    "typescript": "^4.9.5"
  }
}
```

Now, let's start with the unit tests using Jest and React Testing Library:

```javascript
// __tests__/DataTable.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { DataTable } from '../components/DataTable';

interface TestData {
  id: string;
  name: string;
  email: string;
}

describe('DataTable', () => {
  const testData: TestData[] = [
    { id: '1', name: 'John Doe', email: 'john@example.com' },
    { id: '2', name: 'Jane Smith', email: 'jane@example.com' },
    { id: '3', name: 'Bob Johnson', email: 'bob@example.com' },
  ];

  const columns = [
    { label: 'ID', accessor: 'id' },
    { label: 'Name', accessor: 'name' },
    { label: 'Email', accessor: 'email' },
  ];

  it('should render the data table correctly', () => {
    render(<DataTable<TestData> data={testData} columns={columns} onEdit={jest.fn()} onDelete={jest.fn()} />);

    testData.forEach((item) => {
      expect(screen.getByText(item.id)).toBeInTheDocument();
      expect(screen.getByText(item.name)).toBeInTheDocument();
      expect(screen.getByText(item.email)).toBeInTheDocument();
    });
  });

  it('should call the onEdit callback when the edit button is clicked', () => {
    const onEditMock = jest.fn();
    render(<DataTable<TestData> data={testData} columns={columns} onEdit={onEditMock} onDelete={jest.fn()} />);

    const editButton = screen.getAllByRole('button', { name: 'Edit' })[0];
    fireEvent.click(editButton);

    expect(onEditMock).toHaveBeenCalledWith(testData[0]);
  });

  it('should call the onDelete callback when the delete button is clicked', () => {
    const onDeleteMock = jest.fn();
    render(<DataTable<TestData> data={testData} columns={columns} onEdit={jest.fn()} onDelete={onDeleteMock} />);

    const deleteButton = screen.getAllByRole('button', { name: 'Delete' })[0];
    fireEvent.click(deleteButton);

    expect(onDeleteMock).toHaveBeenCalledWith(testData[0]);
  });
});
```

Next, let's write some integration tests using Cypress:

```javascript
// cypress/integration/crud.spec.js
describe('CRUD Operations', () => {
  beforeEach(() => {
    cy.visit('/');
  });

  it('should create a new item', () => {
    cy.get('[data-cy="create-button"]').click();
    cy.get('[data-cy="name-input"]').type('New Item');
    cy.get('[data-cy="email-input"]').type('new@example.com');
    cy.get('[data-cy="save-button"]').click();

    cy.contains('New Item').should('be.visible');
    cy.contains('new@example.com').should('be.visible');
  });

  it('should update an existing item', () => {
    cy.get('[data-cy="edit-button"]').first().click();
    cy.get('[data-cy="name-input"]').clear().type('Updated Item');
    cy.get('[data-cy="email-input"]').clear().type('updated@example.com');
    cy.get('[data-cy="save-button"]').click();

    cy.contains('Updated Item').should('be.visible');
    cy.contains('updated@example.com').should('be.visible');
  });

  it('should delete an item', () => {
    cy.get('[data-cy="delete-button"]').first().click();
    cy.contains('Deleted').should('be.visible');
  });
});
```

In this example, we have a `DataTable` component that displays a table of data with CRUD operations. The unit tests cover the rendering of the table, as well as the `onEdit` and `onDelete` callbacks. The integration tests cover the end-to-end flow of creating, updating, and deleting items.

The key points are:

1. **Unit Tests**: Using Jest and React Testing Library, we test the individual components and their behavior, ensuring they render correctly and trigger the expected callbacks.
2. **Integration Tests**: Using Cypress, we test the overall CRUD flow, simulating user interactions and verifying the expected outcomes.
3. **Test Data**: We use a simple `TestData` interface to represent the data being displayed in the table.
4. **Accessibility**: We use appropriate roles and data-cy attributes to make the tests more readable and maintainable.

This comprehensive test suite ensures that the CRUD operations in your web application work as expected, covering both the individual components and the overall user experience.