import { NextRequest, NextResponse } from 'next/server';
import path from 'path';
import fs from 'fs/promises';

interface TimelineEvent {
  id: string;
  timestamp: string | number;
  type: 'file_change' | 'terminal_command' | 'checkpoint' | 'error';
  description: string;
  details?: any;
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const sessionId = searchParams.get('sessionId');
    
    const dataDir = path.join(process.cwd(), 'data');
    const sessionsDir = path.join(dataDir, 'sessions');
    
    let allCheckpoints: TimelineEvent[] = [];
    
    try {
      if (sessionId) {
        // Get checkpoints for specific session
        const checkpointsDir = path.join(sessionsDir, sessionId, 'checkpoints');
        
        try {
          const checkpointFiles = await fs.readdir(checkpointsDir);
          
          for (const file of checkpointFiles) {
            if (file.endsWith('.json')) {
              const checkpointData = JSON.parse(
                await fs.readFile(path.join(checkpointsDir, file), 'utf8')
              );
              
              allCheckpoints.push({
                id: checkpointData.id,
                timestamp: checkpointData.timestamp,
                type: 'checkpoint' as const,
                description: checkpointData.name || 'Checkpoint',
                details: {
                  sessionId: checkpointData.sessionId,
                  description: checkpointData.description,
                  data: checkpointData.data,
                  tags: checkpointData.tags,
                  autoGenerated: checkpointData.autoGenerated
                }
              });
            }
          }
        } catch (error) {
          // Session or checkpoints directory doesn't exist, return empty
          logger?.warn(`No checkpoints found for session ${sessionId}`);
        }
      } else {
        // Get checkpoints from all sessions for comprehensive timeline
        try {
          const sessions = await fs.readdir(sessionsDir);
          
          // Limit to recent 5 sessions for performance
          const recentSessions = sessions.sort().slice(-5);
          
          for (const sessionDir of recentSessions) {
            const checkpointsDir = path.join(sessionsDir, sessionDir, 'checkpoints');
            const metadataPath = path.join(sessionsDir, sessionDir, 'metadata.json');
            
            let sessionName = sessionDir;
            try {
              const metadata = JSON.parse(await fs.readFile(metadataPath, 'utf8'));
              sessionName = metadata.name || sessionDir;
            } catch {
              // Metadata file doesn't exist, use directory name
            }
            
            try {
              const checkpointFiles = await fs.readdir(checkpointsDir);
              
              for (const file of checkpointFiles) {
                if (file.endsWith('.json')) {
                  const checkpointData = JSON.parse(
                    await fs.readFile(path.join(checkpointsDir, file), 'utf8')
                  );
                  
                  allCheckpoints.push({
                    id: checkpointData.id,
                    timestamp: checkpointData.timestamp,
                    type: 'checkpoint' as const,
                    description: `${sessionName}: ${checkpointData.name || 'Checkpoint'}`,
                    details: {
                      sessionId: checkpointData.sessionId,
                      sessionName,
                      description: checkpointData.description,
                      data: checkpointData.data,
                      tags: checkpointData.tags,
                      autoGenerated: checkpointData.autoGenerated
                    }
                  });
                }
              }
            } catch (error) {
              // Checkpoints directory doesn't exist for this session
              logger?.warn(`No checkpoints found for session ${sessionDir}`);
            }
          }
        } catch (error) {
          // Sessions directory doesn't exist
          logger?.warn('No sessions directory found');
        }
      }
    } catch (error) {
      logger?.warn('Error reading session data:', error);
    }
    
    // Sort by timestamp (newest first)
    allCheckpoints.sort((a, b) => {
      const timeA = typeof a.timestamp === 'string' ? new Date(a.timestamp).getTime() : a.timestamp;
      const timeB = typeof b.timestamp === 'string' ? new Date(b.timestamp).getTime() : b.timestamp;
      return timeB - timeA;
    });
    
    return NextResponse.json({ 
      success: true,
      events: allCheckpoints.slice(0, 50), // Return last 50 events
      total: allCheckpoints.length
    });
    
  } catch (error) {
    logger?.error('Failed to fetch timeline:', error);
    return NextResponse.json(
      { error: 'Failed to fetch timeline' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const event = await request.json();
    
    const timelineEvent: TimelineEvent = {
      id: `event-${Date.now()}`,
      timestamp: new Date().toISOString(),
      ...event
    };
    
    // Save to global timeline file for tracking all events
    const dataDir = path.join(process.cwd(), 'data');
    const globalTimelineDir = path.join(dataDir, 'timeline');
    const globalTimelineFile = path.join(globalTimelineDir, 'global-timeline.json');
    
    await fs.mkdir(globalTimelineDir, { recursive: true });
    
    let globalTimeline = [];
    try {
      const existingData = await fs.readFile(globalTimelineFile, 'utf8');
      globalTimeline = JSON.parse(existingData);
    } catch {
      // File doesn't exist yet, start with empty array
      globalTimeline = [];
    }
    
    globalTimeline.push(timelineEvent);
    
    // Keep only last 1000 events for performance
    if (globalTimeline.length > 1000) {
      globalTimeline = globalTimeline.slice(-1000);
    }
    
    await fs.writeFile(globalTimelineFile, JSON.stringify(globalTimeline, null, 2));
    
    return NextResponse.json({ 
      success: true,
      event: timelineEvent
    });
    
  } catch (error) {
    logger?.error('Failed to add timeline event:', error);
    return NextResponse.json(
      { error: 'Failed to add timeline event' },
      { status: 500 }
    );
  }
}