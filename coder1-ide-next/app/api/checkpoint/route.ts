import { NextRequest, NextResponse } from 'next/server';
import path from 'path';
import fs from 'fs/promises';
import { contextDatabase } from '@/services/context-database';
import { processCheckpointDataForSave } from '@/lib/checkpoint-utils';

export const dynamic = 'force-dynamic';

// Self-contained checkpoint storage
export async function POST(request: NextRequest) {
  try {
    const data = await request.json();
    
    // Get or create sessionId
    const sessionId = data.sessionId || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const checkpointId = `checkpoint_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Ensure data directory structure exists
    const dataDir = path.join(process.cwd(), 'data');
    const sessionDir = path.join(dataDir, 'sessions', sessionId);
    const checkpointsDir = path.join(sessionDir, 'checkpoints');
    
    await fs.mkdir(checkpointsDir, { recursive: true });
    
    // Create session metadata if it doesn't exist
    const sessionMetadataPath = path.join(sessionDir, 'metadata.json');
    try {
      await fs.access(sessionMetadataPath);
    } catch {
      // Session metadata doesn't exist, create it with intelligent naming
      const now = new Date();
      const hour = now.getHours();
      const timeOfDay = hour < 6 ? 'Late Night' : 
                       hour < 12 ? 'Morning' : 
                       hour < 17 ? 'Afternoon' : 
                       hour < 21 ? 'Evening' : 'Night';
      
      const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
      const dateStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      
      const sessionMetadata = {
        id: sessionId,
        name: `ðŸ’» ${timeOfDay} Coding Session - ${dateStr} ${timeStr}`,
        description: `Coder1 IDE ${timeOfDay.toLowerCase()} development session`,
        createdAt: now.toISOString(),
        lastUpdated: now.toISOString()
      };
      await fs.writeFile(sessionMetadataPath, JSON.stringify(sessionMetadata, null, 2));
    }
    
    // ENHANCED: Query conversation history from context database BEFORE creating checkpoint
    let conversationHistory: any[] = [];
    try {
      // Get recent conversations for this terminal session/project
      const currentProjectPath = process.cwd();
      
      // Try to get context folder and recent conversations
      // Wrap in additional safety check for database availability
      if (contextDatabase && typeof contextDatabase.getOrCreateFolder === 'function') {
        try {
          const folder = await contextDatabase.getOrCreateFolder(currentProjectPath);
          if (folder) {
            // Get recent conversations from this folder (across all sessions)
            conversationHistory = await contextDatabase.getRecentConversations(folder.id, 10);
            console.log(`ðŸ“Š Enhanced checkpoint: Found ${conversationHistory.length} recent conversations`);
          }
        } catch (dbError) {
          console.warn('âš ï¸ Context database error, continuing without conversation history:', dbError);
        }
      } else {
        console.log('â„¹ï¸ Context database not available, checkpoint will save without conversation history');
      }
    } catch (error) {
      console.warn('âš ï¸ Could not retrieve conversation history for checkpoint:', (error as Error).message);
      // Continue without conversation history - don't fail the checkpoint creation
    }

    // Filter snapshot data to remove thinking animations and artifacts
    const filteredSnapshot = processCheckpointDataForSave(data.snapshot);
    
    // Create enhanced checkpoint with conversation history
    const checkpoint = {
      id: checkpointId,
      sessionId,
      name: data.autoGenerated ? `Auto-checkpoint ${new Date().toLocaleDateString('en-US')} ${new Date().toLocaleTimeString()}` : `Checkpoint ${new Date().toLocaleDateString('en-US')} ${new Date().toLocaleTimeString()}`,
      description: data.autoGenerated ? 'Auto-generated checkpoint from IDE' : 'Manual checkpoint from IDE',
      timestamp: new Date().toISOString(),
      data: {
        timestamp: data.timestamp,
        activeFile: data.activeFile,
        snapshot: filteredSnapshot,  // â† Filtered to remove thinking animations
        conversationHistory: conversationHistory  // â† Enhanced with conversation data
      },
      tags: ['ide', data.autoGenerated ? 'auto' : 'manual'],
      autoGenerated: data.autoGenerated || false
    };
    
    // Save enhanced checkpoint
    const checkpointPath = path.join(checkpointsDir, `${checkpointId}.json`);
    await fs.writeFile(checkpointPath, JSON.stringify(checkpoint, null, 2));

    // Update session metadata
    const sessionData = JSON.parse(await fs.readFile(sessionMetadataPath, 'utf8'));
    sessionData.lastUpdated = new Date().toISOString();
    await fs.writeFile(sessionMetadataPath, JSON.stringify(sessionData, null, 2));
    
    return NextResponse.json({
      success: true,
      checkpoint,
      sessionId
    });
    
  } catch (error) {
    console.error('Checkpoint API error:', error);
    return NextResponse.json(
      { error: 'Failed to create checkpoint' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const sessionId = searchParams.get('sessionId');
    
    const dataDir = path.join(process.cwd(), 'data');
    const sessionsDir = path.join(dataDir, 'sessions');
    
    if (!sessionId) {
      // If no sessionId, find the latest session
      try {
        const sessions = await fs.readdir(sessionsDir);
        if (sessions.length > 0) {
          // Get the most recent session (assuming folder names have timestamps)
          const latestSession = sessions.sort().pop();
          const checkpointsDir = path.join(sessionsDir, latestSession!, 'checkpoints');
          
          try {
            const checkpointFiles = await fs.readdir(checkpointsDir);
            const checkpoints = [];
            
            for (const file of checkpointFiles) {
              if (file.endsWith('.json')) {
                const checkpointData = JSON.parse(
                  await fs.readFile(path.join(checkpointsDir, file), 'utf8')
                );
                checkpoints.push(checkpointData);
              }
            }
            
            // Sort by timestamp (newest first)
            checkpoints.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
            
            return NextResponse.json({ 
              success: true,
              checkpoints,
              sessionId: latestSession
            });
          } catch {
            return NextResponse.json({ 
              success: true,
              checkpoints: [],
              sessionId: latestSession
            });
          }
        }
      } catch {
        return NextResponse.json({ 
          success: true,
          checkpoints: []
        });
      }
      
      return NextResponse.json({ 
        success: true,
        checkpoints: []
      });
    }
    
    // Fetch checkpoints for specific session
    const checkpointsDir = path.join(sessionsDir, sessionId, 'checkpoints');
    
    try {
      const checkpointFiles = await fs.readdir(checkpointsDir);
      const checkpoints = [];
      
      for (const file of checkpointFiles) {
        if (file.endsWith('.json')) {
          const checkpointData = JSON.parse(
            await fs.readFile(path.join(checkpointsDir, file), 'utf8')
          );
          checkpoints.push(checkpointData);
        }
      }
      
      // Sort by timestamp (newest first)
      checkpoints.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
      
      return NextResponse.json({ 
        success: true,
        checkpoints,
        sessionId
      });
      
    } catch (error) {
      // Directory doesn't exist or other error
      return NextResponse.json({ 
        success: true,
        checkpoints: [],
        sessionId
      });
    }
    
  } catch (error) {
    console.error('Checkpoint fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch checkpoints' },
      { status: 500 }
    );
  }
}