import { NextRequest, NextResponse } from 'next/server';
import path from 'path';
import fs from 'fs/promises';

export const dynamic = 'force-dynamic';

// Self-contained checkpoint storage
export async function POST(request: NextRequest) {
  try {
    const data = await request.json();
    
    // Get or create sessionId
    const sessionId = data.sessionId || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const checkpointId = `checkpoint_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Ensure data directory structure exists
    const dataDir = path.join(process.cwd(), 'data');
    const sessionDir = path.join(dataDir, 'sessions', sessionId);
    const checkpointsDir = path.join(sessionDir, 'checkpoints');
    
    await fs.mkdir(checkpointsDir, { recursive: true });
    
    // Create session metadata if it doesn't exist
    const sessionMetadataPath = path.join(sessionDir, 'metadata.json');
    try {
      await fs.access(sessionMetadataPath);
    } catch {
      // Session metadata doesn't exist, create it
      const sessionMetadata = {
        id: sessionId,
        name: `IDE Session ${new Date().toLocaleString()}`,
        description: 'Created from Coder1 IDE',
        createdAt: new Date().toISOString(),
        lastUpdated: new Date().toISOString()
      };
      await fs.writeFile(sessionMetadataPath, JSON.stringify(sessionMetadata, null, 2));
    }
    
    // Create checkpoint
    const checkpoint = {
      id: checkpointId,
      sessionId,
      name: data.autoGenerated ? `Auto-checkpoint ${new Date().toLocaleTimeString()}` : `Checkpoint ${new Date().toLocaleTimeString()}`,
      description: data.autoGenerated ? 'Auto-generated checkpoint from IDE' : 'Manual checkpoint from IDE',
      timestamp: new Date().toISOString(),
      data: {
        timestamp: data.timestamp,
        activeFile: data.activeFile,
        snapshot: data.snapshot
      },
      tags: ['ide', data.autoGenerated ? 'auto' : 'manual'],
      autoGenerated: data.autoGenerated || false
    };
    
    // Save checkpoint
    const checkpointPath = path.join(checkpointsDir, `${checkpointId}.json`);
    await fs.writeFile(checkpointPath, JSON.stringify(checkpoint, null, 2));
    
    // Update session metadata
    const sessionData = JSON.parse(await fs.readFile(sessionMetadataPath, 'utf8'));
    sessionData.lastUpdated = new Date().toISOString();
    await fs.writeFile(sessionMetadataPath, JSON.stringify(sessionData, null, 2));
    
    return NextResponse.json({
      success: true,
      checkpoint,
      sessionId
    });
    
  } catch (error) {
    console.error('Checkpoint API error:', error);
    return NextResponse.json(
      { error: 'Failed to create checkpoint' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const sessionId = searchParams.get('sessionId');
    
    const dataDir = path.join(process.cwd(), 'data');
    const sessionsDir = path.join(dataDir, 'sessions');
    
    if (!sessionId) {
      // If no sessionId, find the latest session
      try {
        const sessions = await fs.readdir(sessionsDir);
        if (sessions.length > 0) {
          // Get the most recent session (assuming folder names have timestamps)
          const latestSession = sessions.sort().pop();
          const checkpointsDir = path.join(sessionsDir, latestSession!, 'checkpoints');
          
          try {
            const checkpointFiles = await fs.readdir(checkpointsDir);
            const checkpoints = [];
            
            for (const file of checkpointFiles) {
              if (file.endsWith('.json')) {
                const checkpointData = JSON.parse(
                  await fs.readFile(path.join(checkpointsDir, file), 'utf8')
                );
                checkpoints.push(checkpointData);
              }
            }
            
            // Sort by timestamp (newest first)
            checkpoints.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
            
            return NextResponse.json({ 
              success: true,
              checkpoints,
              sessionId: latestSession
            });
          } catch {
            return NextResponse.json({ 
              success: true,
              checkpoints: [],
              sessionId: latestSession
            });
          }
        }
      } catch {
        return NextResponse.json({ 
          success: true,
          checkpoints: []
        });
      }
      
      return NextResponse.json({ 
        success: true,
        checkpoints: []
      });
    }
    
    // Fetch checkpoints for specific session
    const checkpointsDir = path.join(sessionsDir, sessionId, 'checkpoints');
    
    try {
      const checkpointFiles = await fs.readdir(checkpointsDir);
      const checkpoints = [];
      
      for (const file of checkpointFiles) {
        if (file.endsWith('.json')) {
          const checkpointData = JSON.parse(
            await fs.readFile(path.join(checkpointsDir, file), 'utf8')
          );
          checkpoints.push(checkpointData);
        }
      }
      
      // Sort by timestamp (newest first)
      checkpoints.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
      
      return NextResponse.json({ 
        success: true,
        checkpoints,
        sessionId
      });
      
    } catch (error) {
      // Directory doesn't exist or other error
      return NextResponse.json({ 
        success: true,
        checkpoints: [],
        sessionId
      });
    }
    
  } catch (error) {
    console.error('Checkpoint fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch checkpoints' },
      { status: 500 }
    );
  }
}