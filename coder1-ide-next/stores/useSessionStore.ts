/**
 * Session State Store (Zustand)
 * Centralized state management for session data and AI agent coordination
 */

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { 
  SessionData,
  SessionMetadata, 
  SessionCheckpoint,
  SessionInsight,
  SessionSummaryResult,
  AgentSession,
  TeamSession,
  SupervisionState
} from '@/types';

// ================================================================================
// Session Store Interface
// ================================================================================

interface SessionStore {
  // Current session
  currentSession: SessionData | null;
  
  // Session history
  sessionHistory: SessionMetadata[];
  
  // AI Agents
  activeAgents: AgentSession[];
  activeTeam: TeamSession | null;
  
  // Supervision
  supervision: SupervisionState;
  
  // Session Summary
  lastSummary: SessionSummaryResult | null;
  summaryInProgress: boolean;
  summaryProgress: number;
  summaryStep: string;
  
  // ================================================================================
  // Session Actions
  // ================================================================================
  
  startSession: (type?: SessionData['metadata']['type']) => void;
  endSession: () => void;
  pauseSession: () => void;
  resumeSession: () => void;
  updateSessionData: (data: Partial<SessionData>) => void;
  
  // ================================================================================
  // Checkpoint Actions
  // ================================================================================
  
  createCheckpoint: (description: string, autoGenerated?: boolean) => void;
  loadCheckpoint: (checkpointId: string) => void;
  deleteCheckpoint: (checkpointId: string) => void;
  
  // ================================================================================
  // Insights Actions
  // ================================================================================
  
  addInsight: (insight: Omit<SessionInsight, 'id' | 'timestamp'>) => void;
  removeInsight: (insightId: string) => void;
  updateInsight: (insightId: string, updates: Partial<SessionInsight>) => void;
  
  // ================================================================================
  // Agent Actions
  // ================================================================================
  
  spawnAgent: (agentId: string, task: string) => void;
  updateAgentStatus: (sessionId: string, status: AgentSession['status']) => void;
  updateAgentProgress: (sessionId: string, progress: number) => void;
  addAgentOutput: (sessionId: string, output: string, type?: 'message' | 'code' | 'file' | 'error') => void;
  removeAgent: (sessionId: string) => void;
  
  // ================================================================================
  // Team Actions
  // ================================================================================
  
  spawnTeam: (requirement: string, workflow?: string) => void;
  updateTeamStatus: (status: TeamSession['status']) => void;
  disbandTeam: () => void;
  
  // ================================================================================
  // Supervision Actions
  // ================================================================================
  
  enableSupervision: (triggeredBy?: SupervisionState['triggeredBy']) => void;
  disableSupervision: () => void;
  updateSupervisionStatus: (status: SupervisionState['status']) => void;
  addSupervisionRecommendation: (recommendation: Omit<SupervisionState['recommendations'][0], 'id' | 'timestamp' | 'dismissed'>) => void;
  dismissRecommendation: (recommendationId: string) => void;
  
  // ================================================================================
  // Session Summary Actions
  // ================================================================================
  
  startSummaryGeneration: () => void;
  updateSummaryProgress: (progress: number, step: string) => void;
  completeSummaryGeneration: (result: SessionSummaryResult) => void;
  clearSummary: () => void;
  
  // ================================================================================
  // History Actions
  // ================================================================================
  
  loadSessionHistory: () => void;
  clearSessionHistory: () => void;
  deleteSession: (sessionId: string) => void;
  
  // ================================================================================
  // Utility Actions
  // ================================================================================
  
  reset: () => void;
}

// ================================================================================
// Initial State
// ================================================================================

const initialState = {
  currentSession: null as SessionData | null,
  
  sessionHistory: [] as SessionMetadata[],
  
  activeAgents: [] as AgentSession[],
  activeTeam: null as TeamSession | null,
  
  supervision: {
    isActive: false,
    status: 'inactive' as const,
    triggeredBy: 'manual' as const,
    lastCheck: null,
    recommendations: [],
    context: {
      recentErrors: [],
      codeContext: [],
      sessionHistory: [],
    }
  } as SupervisionState,
  
  lastSummary: null as SessionSummaryResult | null,
  summaryInProgress: false,
  summaryProgress: 0,
  summaryStep: '',
};

// ================================================================================
// Utility Functions
// ================================================================================

const generateSessionId = () => `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
const generateCheckpointId = () => `checkpoint_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
const generateInsightId = () => `insight_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
const generateAgentSessionId = () => `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
const generateTeamId = () => `team_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

// ================================================================================
// Store Implementation
// ================================================================================

export const useSessionStore = create<SessionStore>()(
  devtools(
    persist(
      (set, get) => ({
        ...initialState,
        
        // ================================================================================
        // Session Actions
        // ================================================================================
        
        startSession: (type = 'general') => {
          const sessionId = generateSessionId();
          const newSession: SessionData = {
            metadata: {
              sessionId,
              startTime: new Date(),
              type,
              status: 'active',
            },
            openFiles: [],
            activeFile: null,
            terminalHistory: '',
            terminalCommands: [],
            editorContent: '',
            checkpoints: [],
            insights: [],
          };
          
          set((state) => ({
            currentSession: newSession,
            sessionHistory: [newSession.metadata, ...state.sessionHistory.slice(0, 49)] // Keep last 50
          }), false, `startSession:${type}`);
        },
        
        endSession: () => {
          const { currentSession } = get();
          if (!currentSession) return;
          
          const endTime = new Date();
          const duration = Math.round((endTime.getTime() - currentSession.metadata.startTime.getTime()) / 60000);
          
          set((state) => ({
            currentSession: {
              ...currentSession,
              metadata: {
                ...currentSession.metadata,
                endTime,
                duration,
                status: 'completed',
              }
            },
            sessionHistory: state.sessionHistory.map(session =>
              session.sessionId === currentSession.metadata.sessionId
                ? { ...currentSession.metadata, endTime, duration, status: 'completed' as const }
                : session
            )
          }), false, 'endSession');
          
          // Clear current session after a brief delay to allow for final updates
          setTimeout(() => {
            set({ currentSession: null }, false, 'clearCurrentSession');
          }, 1000);
        },
        
        pauseSession: () => {
          set((state) => ({
            currentSession: state.currentSession ? {
              ...state.currentSession,
              metadata: { ...state.currentSession.metadata, status: 'paused' }
            } : null
          }), false, 'pauseSession');
        },
        
        resumeSession: () => {
          set((state) => ({
            currentSession: state.currentSession ? {
              ...state.currentSession,
              metadata: { ...state.currentSession.metadata, status: 'active' }
            } : null
          }), false, 'resumeSession');
        },
        
        updateSessionData: (data) => {
          set((state) => ({
            currentSession: state.currentSession ? {
              ...state.currentSession,
              ...data
            } : null
          }), false, 'updateSessionData');
        },
        
        // ================================================================================
        // Checkpoint Actions
        // ================================================================================
        
        createCheckpoint: (description, autoGenerated = false) => {
          const { currentSession } = get();
          if (!currentSession) return;
          
          const checkpoint: SessionCheckpoint = {
            id: generateCheckpointId(),
            timestamp: new Date(),
            description,
            snapshot: {
              files: JSON.stringify(currentSession.openFiles),
              terminal: currentSession.terminalHistory,
              editor: currentSession.editorContent,
            },
            autoGenerated,
          };
          
          set((state) => ({
            currentSession: state.currentSession ? {
              ...state.currentSession,
              checkpoints: [...state.currentSession.checkpoints, checkpoint]
            } : null
          }), false, `createCheckpoint:${autoGenerated ? 'auto' : 'manual'}`);
        },
        
        loadCheckpoint: (checkpointId) => {
          const { currentSession } = get();
          if (!currentSession) return;
          
          const checkpoint = currentSession.checkpoints.find(c => c.id === checkpointId);
          if (!checkpoint) return;
          
          try {
            const files = JSON.parse(checkpoint.snapshot.files);
            set((state) => ({
              currentSession: state.currentSession ? {
                ...state.currentSession,
                openFiles: files,
                terminalHistory: checkpoint.snapshot.terminal,
                editorContent: checkpoint.snapshot.editor,
              } : null
            }), false, 'loadCheckpoint');
          } catch (error) {
            logger?.error('Failed to load checkpoint:', error);
          }
        },
        
        deleteCheckpoint: (checkpointId) => {
          set((state) => ({
            currentSession: state.currentSession ? {
              ...state.currentSession,
              checkpoints: state.currentSession.checkpoints.filter(c => c.id !== checkpointId)
            } : null
          }), false, 'deleteCheckpoint');
        },
        
        // ================================================================================
        // Insights Actions
        // ================================================================================
        
        addInsight: (insightData) => {
          const insight: SessionInsight = {
            id: generateInsightId(),
            timestamp: new Date(),
            ...insightData,
          };
          
          set((state) => ({
            currentSession: state.currentSession ? {
              ...state.currentSession,
              insights: [...state.currentSession.insights, insight]
            } : null
          }), false, `addInsight:${insight.type}`);
        },
        
        removeInsight: (insightId) => {
          set((state) => ({
            currentSession: state.currentSession ? {
              ...state.currentSession,
              insights: state.currentSession.insights.filter(i => i.id !== insightId)
            } : null
          }), false, 'removeInsight');
        },
        
        updateInsight: (insightId, updates) => {
          set((state) => ({
            currentSession: state.currentSession ? {
              ...state.currentSession,
              insights: state.currentSession.insights.map(i =>
                i.id === insightId ? { ...i, ...updates } : i
              )
            } : null
          }), false, 'updateInsight');
        },
        
        // ================================================================================
        // Agent Actions
        // ================================================================================
        
        spawnAgent: (agentId, task) => {
          const sessionId = generateAgentSessionId();
          const teamId = get().activeTeam?.teamId || generateTeamId();
          
          const agent: AgentSession = {
            sessionId,
            teamId,
            agentId,
            agentName: agentId, // This would be resolved from agent definitions
            status: 'initializing',
            currentTask: task,
            progress: 0,
            output: [],
            files: [],
            dependencies: [],
            completedDeliverables: [],
            metrics: {
              startTime: new Date(),
              tasksCompleted: 0,
              filesGenerated: 0,
              linesOfCode: 0,
              errorsEncountered: 0,
              successRate: 1,
            }
          };
          
          set((state) => ({
            activeAgents: [...state.activeAgents, agent]
          }), false, `spawnAgent:${agentId}`);
        },
        
        updateAgentStatus: (sessionId, status) => {
          set((state) => ({
            activeAgents: state.activeAgents.map(agent =>
              agent.sessionId === sessionId ? { ...agent, status } : agent
            )
          }), false, `updateAgentStatus:${status}`);
        },
        
        updateAgentProgress: (sessionId, progress) => {
          set((state) => ({
            activeAgents: state.activeAgents.map(agent =>
              agent.sessionId === sessionId ? { ...agent, progress: Math.max(0, Math.min(100, progress)) } : agent
            )
          }), false, 'updateAgentProgress');
        },
        
        addAgentOutput: (sessionId, content, type = 'message') => {
          const output = {
            id: `output_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: new Date(),
            type,
            content,
          };
          
          set((state) => ({
            activeAgents: state.activeAgents.map(agent =>
              agent.sessionId === sessionId ? {
                ...agent,
                output: [...agent.output, output]
              } : agent
            )
          }), false, `addAgentOutput:${type}`);
        },
        
        removeAgent: (sessionId) => {
          set((state) => ({
            activeAgents: state.activeAgents.filter(agent => agent.sessionId !== sessionId)
          }), false, 'removeAgent');
        },
        
        // ================================================================================
        // Team Actions
        // ================================================================================
        
        spawnTeam: (requirement, workflow) => {
          const teamId = generateTeamId();
          const sessionId = get().currentSession?.metadata.sessionId || generateSessionId();
          
          const team: TeamSession = {
            teamId,
            sessionId,
            projectRequirement: requirement,
            workflow: workflow || 'general',
            agents: [],
            status: 'spawning',
            startTime: new Date(),
            files: [],
            context: {
              requirement,
              projectType: 'web-application',
              framework: 'react',
              features: [],
              constraints: [],
            },
            metrics: {
              totalAgents: 0,
              activeAgents: 0,
              completedTasks: 0,
              totalTasks: 0,
              filesGenerated: 0,
              linesOfCode: 0,
              overallProgress: 0,
              efficiency: 1,
              collaboration: 1,
            }
          };
          
          set({ activeTeam: team }, false, `spawnTeam:${workflow}`);
        },
        
        updateTeamStatus: (status) => {
          set((state) => ({
            activeTeam: state.activeTeam ? { ...state.activeTeam, status } : null
          }), false, `updateTeamStatus:${status}`);
        },
        
        disbandTeam: () => {
          set({
            activeTeam: null,
            activeAgents: []
          }, false, 'disbandTeam');
        },
        
        // ================================================================================
        // Supervision Actions
        // ================================================================================
        
        enableSupervision: (triggeredBy = 'manual') => {
          set((state) => ({
            supervision: {
              ...state.supervision,
              isActive: true,
              status: 'monitoring',
              triggeredBy,
              lastCheck: new Date(),
            }
          }), false, `enableSupervision:${triggeredBy}`);
        },
        
        disableSupervision: () => {
          set((state) => ({
            supervision: {
              ...state.supervision,
              isActive: false,
              status: 'inactive',
              lastCheck: new Date(),
            }
          }), false, 'disableSupervision');
        },
        
        updateSupervisionStatus: (status) => {
          set((state) => ({
            supervision: { ...state.supervision, status, lastCheck: new Date() }
          }), false, `updateSupervisionStatus:${status}`);
        },
        
        addSupervisionRecommendation: (recommendationData) => {
          const recommendation = {
            id: `rec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            timestamp: new Date(),
            dismissed: false,
            ...recommendationData,
          };
          
          set((state) => ({
            supervision: {
              ...state.supervision,
              recommendations: [...state.supervision.recommendations, recommendation]
            }
          }), false, `addRecommendation:${recommendation.type}`);
        },
        
        dismissRecommendation: (recommendationId) => {
          set((state) => ({
            supervision: {
              ...state.supervision,
              recommendations: state.supervision.recommendations.map(rec =>
                rec.id === recommendationId ? { ...rec, dismissed: true } : rec
              )
            }
          }), false, 'dismissRecommendation');
        },
        
        // ================================================================================
        // Session Summary Actions
        // ================================================================================
        
        startSummaryGeneration: () => {
          set({
            summaryInProgress: true,
            summaryProgress: 0,
            summaryStep: 'Initializing session analysis...',
            lastSummary: null,
          }, false, 'startSummaryGeneration');
        },
        
        updateSummaryProgress: (progress, step) => {
          set({
            summaryProgress: Math.max(0, Math.min(100, progress)),
            summaryStep: step,
          }, false, 'updateSummaryProgress');
        },
        
        completeSummaryGeneration: (result) => {
          set({
            summaryInProgress: false,
            summaryProgress: 100,
            summaryStep: 'Complete',
            lastSummary: result,
          }, false, 'completeSummaryGeneration');
        },
        
        clearSummary: () => {
          set({
            lastSummary: null,
            summaryInProgress: false,
            summaryProgress: 0,
            summaryStep: '',
          }, false, 'clearSummary');
        },
        
        // ================================================================================
        // History Actions
        // ================================================================================
        
        loadSessionHistory: () => {
          // This would typically load from a persistent store or API
          // For now, we'll use the existing sessionHistory
          // REMOVED: // REMOVED: // REMOVED: console.log('Loading session history...');
        },
        
        clearSessionHistory: () => {
          set({ sessionHistory: [] }, false, 'clearSessionHistory');
        },
        
        deleteSession: (sessionId) => {
          set((state) => ({
            sessionHistory: state.sessionHistory.filter(s => s.sessionId !== sessionId)
          }), false, 'deleteSession');
        },
        
        // ================================================================================
        // Utility Actions
        // ================================================================================
        
        reset: () => set(initialState, false, 'reset'),
      }),
      {
        name: 'coder1-session-store',
        partialize: (state) => ({
          // Only persist session history and current session metadata
          sessionHistory: state.sessionHistory,
          currentSession: state.currentSession ? {
            ...state.currentSession,
            metadata: state.currentSession.metadata,
          } : null,
        }),
      }
    ),
    {
      name: 'Session Store'
    }
  )
);